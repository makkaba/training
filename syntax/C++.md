# C++
## 실행&기타

1. g++ 파일명.cpp && ./a.out
2. '100004로 나눈 나머지를 정답으로 해라'라는 류의 문제 경우 최종 결과를 나누라는 얘기가 아니라 매번 for루프마다 나눈 나머지를 넣으라는 소리인 경우가 대부분이다.
3. BOJ 사이트에는 int 대신 long long 타입으로 하지 않으면 오답처리되는 거지같은 문제들이 종종 있다.

## 전략

1. 제출 전에는 output을 곳곳에 써서 관찰해라.
2. 인풋에 고정적인 것은 무엇인지 파악해서 인풋을 쉽게 받아라.  ex) dosomething 4 helloworld `cin>>a>>b>>c;`
3. 많이 쓰는 코드는 미리 적어놓자 ex)2진수 변환

## 입력읽기 및 할당:첫 단추

### 1.입력
- 테스트케이스 갯수(T)가 정해진 경우


한줄 읽기

```
4
1 2 3 4
```

```
vector<int> a(n+1);
while(T--){
	cin>>a[i];
}
```

(cin을 쓰면 띄어쓰기가 무시된다)



붙어있는 매트릭스 읽기

```
0110100
0110101
1110101
0000111
0100000
0111110
0111000
```
```
for(int i=0; i<n; i++){
    for(int j=0; j<n; j++){
        scanf("%1d", &a[i][j]);
    }
}
```

- 갯수가 정해지지 않은 경우(드물지만..)
(진짜 이렇게 출제하지 마라ㅡㅡ)

ex)
`
2 9 10 11 24
`

```
string s;
getline(cin, s);

```
- 갯수가 정해지지 않은 경우

ex)


### 2.할당
할당을 정확히 하지 않으면 오답을 리턴하거나 
컴파일 에러로 당황해서 말리는 수가 많다.

- 메모이제이션 배열

주로 다이나믹 프로그래밍에서
1<=N<=1000와 같은 범위를 주고 계산을 하라는 문제가 있는데  
memoization을 할 때 담는 그릇을 다음과 같이 선언하면 안된다.

```
dp[1000]
```
c의 배열은 몇칸인지를 기반으로 생성된다.  
따라서, 다음과 같이 생성해줘야 0~1000번째 인덱스를 가진 칸까지 생성이 된다.

```
dp[1001]
```

- 상수

```
#define MAX 100001
#define MOD 1000000007
```

## 문자열

```
s1 = "Hello";
s2 = "World";
s3 = s1[0] + s2.substr(1);
Horld
```

- 문자열 각 자리를 바꿔서 다시 리턴

유니코드 상 +3을 해서 문자열을 바꿔라

```
int solution(string s){
	answer = 0;
	for(int i=0; i<s.size(); i++){
			
	}
	return answer;
}

```
## 다이나믹 프로그래밍
- 끝부터 정해본다 ex)마지막에 1을 두었을때 그 앞에 올 수 있는 경우의 수는?
- fix되는 경우가 무엇인지 살펴본다. 건너뛰어도 되는 경우가 있는지 살펴본다.ex)0, 1 중 연속으로 1이 올 수 없다면 1전에는 무조건 0이 와야 한다. 


- n번째 올 수 있는 경우의 수가 여러가지인 경우

즉, 10844번 문제처럼 가지치기 형태로 경우의 수가 생기는 경우.
2차원 배열로 메모이제이션을 계획해야 한다.  
`ex) dp[i][j] = i번째에 j를 두었을 때 경우의 수 ,
dp[i][j] = i 앞에 j를 두었을 때 경우의 수`



## 그래프
- 4방향 탐색

```
vector<int> dy = {0,1,0,-1};
vector<int> dx = {1,0,-1,0};
   
for(int i=0; i<4; i++){
    yy = y+dy[i];
    xx = x+dx[i];
    cout<<yy<<","<<xx<<'\n';
}

```

- 탐색 조건 필터링

```
if(yy <0 | yy>n | xx<0 | xx>n | visited[yy][xx] == true){
	continue;
}
sum += findPath(yy,xx);
```
조건이 많을 때는 반대의 조건을 or로 연결해서 continue로 무시해버리는게 좋다.

## 벡터
- 단순 정렬

```
sort(a.begin(), a.end());
```

- 커스텀 sort

```

```

## 기타

- 전역변수를 쓰자.

전역변수를 쓰는것이 PS에서는 나쁜 것이 아니다.
어차피 환경을 통제하고 알고리즘을 보는 것이기 때문에.

이런 방법도 있긴 한데 (2차원 벡터 -1로 초기화)

```
vector<vector<int>> visited(size, vector<int> (size, -1));
```
visited는 갯수가 정해져있기 때문에 벡터로 할 필요가 없다. 글로벌 변수로 선언하자. 초기화는 함수 안에서 해줘야 한다.

```
bool visited[50][50];
```

- for문을 수동으로 써야할 때가 많으니 미리 복사해놓자.

```
for(int i=0; i<n; i++){
	for(int j=0; j<n; j++){
		
	}
}
```
